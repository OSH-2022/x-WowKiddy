# state machine replication 

## 引言
​	在用户与服务方面，每个服务由一个或者多个服务器组成，并且对应客户提出的请求而调用不同的操作。我们可以使用单一的、集中的服务器来实现服务需求，这样的做法的容错性非常低，如果容错性无法达到我们的要求时，我们需要使用多个独立的服务器，同时使用协议来协调客户与这些副本的交互。

## 多副本的容错性分析
​	对于具有多个副本的文件系统，通常情况下，根据状态或输出的不同，其中一个副本的故障会被检测到。如果对于容错所需的最小拷贝数是三，其中一个有故障，另外两个与之相比，从而确定故障。但是两个副本是不够的，三副本最多可以支持一次故障，之后必须修复和替换又问题的副本，如果不只一个副本发生故障，那么三个服务器的状态和输出都会不同，无法判断正确性。一般来说，对于支持F个故障的系统必须有至少2F+1个副本。但是如果我们可以保证一个出错的副本可以在不产生输出的情况下停止，那么我们只需要F+1个副本，并且客户可以接受系统产生的第一个输出。而一个副本在不同方向上发送不同的值（例如，正确的输出到一些其他的副本，而不正确的输出到其他的副本）的故障被称为 Byzantine Failures。2F+1个副本，用非加密的哈希值足以让所有非恶意的拜占庭故障（概率很高）存活下来。恶意攻击需要加密原语来实现2F+1（使用消息签名），或者可以应用非加密技术，但复制的数量必须增加到3F+1。

## 使用状态机的处理方法
​	通过上述分析我们可以得到使用状态机的处理方式
1.  将状态机的副本放在多个不同的、独立的服务器上。
2.  接受客户的请求，对应着状态机的输入。
3.  对于输入指定一个顺序。
4.  在每一个服务器上按照这个给定的顺序来执行。
5.  用各个状态机的输出结果响应客户。
6.  监控每个复制体状态或输出的差异。

## 实现的技术细节
​	上述各个步骤中，第三步是非常关键的一步。构建状态机形式的分布式系统的关键步骤就是为输入的处理选择一个顺序，由于非故障的副本在得到相同的输入时都会到达相同的状态和输出，那么输入必须是以相同的顺序提交给每个副本。对于Visible Channel来说，这是参与系统的两个实体之间的通信路径，例如服务器到客户端，客户端到服务器等，和Hidden Channel是不向系统透露的通信路径，例如客户端到客户端的通信通常是隐蔽的，一个进程将内容写在磁盘上，另一个进程去读取。当我们所有的通信路径都是可见的时候，可以从通信的模式中推理出一个顺序，按照该顺序进行状态机的输入。而在开放系统中，Hidden Channel很常见，必须使用一个较弱的排序形式，输入的顺序可以通过一个投票的方式来定义，其结果仅取决与可见通信路径。

​	对于步骤五中的数据输出，客户端的请求被解释为状态机的输入，同时需要以适当顺序处理为输出，每一个副本将产生一个输出，无故障的副本始终产生相同的输出，所以对于客户端来说必须过滤掉有问题的输出。如果没有大部分副本具有相同的输出，则有可能发生了系统故障。

​	对于监控状态与输出来说，很难判断一个复制品是否失效，有可能它只是反应存在延迟。一个常见的实现是在服务器之间传递当前副本状态和最近的输出进行校验，如果检测到偏差，则每个服务器上的监控程序会重新启动本地的副本。

